### C03
#### inheritance
**Modes of Inheritance:** There are 3 modes of inheritance.

1.  **Public Mode**: If we derive a subclass from a public base class. Then the public member of the base class will become public in the derived class and protected members of the base class will become protected in the derived class.
2.  **Protected Mode**: If we derive a subclass from a Protected base class. Then both public members and protected members of the base class will become protected in the derived class.
3.  **Private Mode**: If we derive a subclass from a Private base class. Then both public members and protected members of the base class will become Private in the derived class.

- The private members in the base class cannot be directly accessed in the derived class, while protected members can be directly accessed. 

![[Pasted image 20230415133314.png]]

ex03
##### diamond problem
https://www.makeuseof.com/what-is-diamond-problem-in-cpp/

in this excersice, we are encountered with a diamond problem. in which we have a grand parent class (claptrap) that the parent class of diamondtrap are his children. 
the problem is that every instance of diamontrap would call the parents constructor and the constructors each, would call the grand parent. 
solution is using the "virtual" word when defining the inheritance of FragTrap and ScavTrap.
This is usually called “virtual inheritance," which guarantees that only a single instance of the inherited class (in this case, the ClapTrap class) is passed on.

In other words, DiamondTrap class will have a single instance of the ClapTrap class, shared by both the FragTrap and ScavTrap classes. By having a single instance of the ClapTrap class, the ambiguity is resolved.


#### ambiguity 

in the =operator for example, this code was ambiguous :

```
this->setEnergyPoints(src.getEnergyPoints());
```

but this code was not: 

```
this->ScavTrap::setEnergyPoints(src.ScavTrap::getEnergyPoints());
```


##### set-get encapsulation
when we have multiple inheritance like in here, we absolutely need a set/get structure. since this excercise I used to have only get funcs, cause the value were being aletered only from inside of the class. 
but now, I see that in inheritance, no private attribute of parent class is available for children, so a set fucntion is needed. 

##### the copy constructor

When we create a copy constructor for a sub class, we need to call the copy constructor of the base class(es) explicitly. This is because the base class(es) also need to be copied in order to create a complete copy of the derived class object.

If we don't call the base class copy constructor, the data members inherited from the base class(es) may not be copied correctly. Additionally, if the base class(es) have non-default constructors or require special handling during copying, we need to make sure that those constructors or functions are called explicitly in the derived class copy constructor.

For example, if you have a derived class `B` that inherits from a base class `A`, and `A` has a non-default constructor, you need to explicitly call the `A` copy constructor in the `B` copy constructor. Otherwise, the `A` object in the `B` object may not be initialized correctly, leading to undefined behavior.

##### the _clap_trap suffix
normally: 

Then, when I call `this->FragTrap::setName(name + "_clap_trap")`, I am calling the `setName()` method of the `FragTrap` class and passing it a modified version of the given `name`. This will set the `_name_` attribute of the `FragTrap` class to `name + "_clap_trap"`.

Since `DiamondTrap` inherits from both `ScavTrap` and `FragTrap`, it now has two separate `_name_` attributes, one inherited from `ScavTrap` and one inherited from `FragTrap`. The `_name_` attribute of the `DiamondTrap` class itself is also separate. Therefore, setting the `_name_` attribute of one subclass (e.g., `FragTrap`) does not affect the `_name_` attribute of the other subclass (e.g., `ScavTrap`) or the `_name_` attribute of the `DiamondTrap` class itself.

![[Pasted image 20230419191219.png]]
but when I have virtual inheritance, this happens:

when we change one attribute of grandparent, it is changed in both of the parents: 

![[Pasted image 20230419190342.png]]

although I only set the name of `FragTrap`, the name of `ScavTrap` was also set to the name + `_clap_trap.`

##### -Wshadow & -Wno-shadow

The `-Wshadow` compiler flag is used to enable warnings for local variable declarations that shadow a variable declared at a higher level. Shadowing occurs when a variable declared in an inner block has the same name as a variable declared in an outer block. This can cause confusion and errors when accessing variables. Enabling `-Wshadow` will warn you when such shadowing occurs, helping you to avoid these errors.

The `-Wno-shadow` flag is used to disable the warnings generated by `-Wshadow`. This can be useful in situations where shadowing is intentional and does not cause any problems.

the `-Wshadow` flag can show a warning if the name of a class is similar to the name of a subclass variable. This can happen if a variable in a subclass has the same name as a class in a parent or global scope. Here's an example:

![[Pasted image 20230419195735.png]]

In this example, the `doSomething` method of `MySubclass` takes an integer parameter named `myVar`, which has the same name as the `myVar` variable defined in `MyClass`. This can lead to confusion and errors, so the `-Wshadow` flag can be used to warn the programmer about this potential issue.
